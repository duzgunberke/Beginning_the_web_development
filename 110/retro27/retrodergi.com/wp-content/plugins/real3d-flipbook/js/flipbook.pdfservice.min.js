/* v 3.9
author http://codecanyon.net/user/creativeinteractivemedia/portfolio?ref=creativeinteractivemedia
*/

var FLIPBOOK = FLIPBOOK || {};
FLIPBOOK.PdfService = function(i, e, u) {
    var h = this;
    this.pdfDocument = i, this.pdfInfo = i._pdfInfo, this.numPages = this.pdfInfo.numPages, this.webgl = "webgl" == u.viewMode, this.options = u, this.main = u.main, this.model = e, this.pages = [], this.thumbs = [], this.canvasBuffer = [], this.viewports = [], this.textContents = [], this.pdfPages = [], this.pdfAnnotations = [], this.eventBus = new EventBus, this.linkService = new PDFLinkService({
        eventBus: this.eventBus
    }), this.linkService.setViewer(this.main), this.linkService.setDocument(i), this.linkService.externalLinkTarget = 2, window._dbg = 0, this.getCanvas = function() {
        var e, t;
        for (e = 0; e < this.canvasBuffer.length; e++) {
            if ((t = this.canvasBuffer[e]).available) {
                t.available = !1, t.double = !1;
                break
            }
            t = null
        }
        return t || ((t = document.createElement("canvas")).available = !1, t.index = this.canvasBuffer.length, this.canvasBuffer.push(t)), t.rendering = !0, t
    }, this.isRendering = function(t, n) {
        var i = !1;
        return this.canvasBuffer.forEach(function(e) {
            e.size == n && e.pdfPageIndex == t && e.rendering && (i = !0)
        }), i
    }, this.isRendered = function(t, n) {
        var i = !1;
        return this.canvasBuffer.forEach(function(e) {
            e.size == n && e.pdfPageIndex == t && e.rendered && (i = !0)
        }), i
    }, this.setRightIndex = function(t) {
        var n = this,
            i = [];
        this.options.isMobile;
        this.canvasBuffer.forEach(function(e) {
            (!e.rendering && 7 < t - e.pageIndex || t - e.pageIndex < -6) && -1 < e.pageIndex && (-1 < e.pdfPageIndex && (delete n.pages[e.pdfPageIndex].canvas[e.size], n.pages[e.pdfPageIndex].cleanup()), i.push({
                index: e.pageIndex,
                size: e.size
            }), e.double && i.push({
                index: e.pageIndex - 1,
                size: e.size
            }), e.getContext("2d").clearRect(0, 0, e.width, e.height), e.width = e.height = 0, e.pageIndex = -100, e.available = !0, e.rendered = !1)
        }), 0 < i.length && this.model.trigger("pageUnloaded", {
            unloadedPages: i
        })
    }, this.loadThumbs = function(t, n) {
        var i = this;
        this.thumbLoading = this.thumbLoading || 0, this.thumbLoading >= this.pdfInfo.numPages ? n.call(i) : this.loadThumb(this.thumbLoading, function(e) {
            i.options.thumbLoaded(e), i.thumbLoading++, i.loadThumbs(t, n)
        })
    }, this.loadThumb = function(s, o) {
        var l = this;
        this.getViewport(s, function() {
            var e = l.pages[s],
                t = 100 / e.getViewport({
                    scale: 1
                }).height,
                n = e.getViewport({
                    scale: t
                }),
                i = document.createElement("canvas");
            i.index = s;
            var a = i.getContext("2d");
            i.height = n.height, i.width = n.width;
            var r = {
                canvasContext: a,
                viewport: n
            };
            e.cleanupAfterRender = !0, e.render(r).then(function() {
                e.cleanup(), o && o.call(l, i)
            })
        })
    }, this.init = function(t) {
        h.getViewport(0, function(e) {
            h.r1 = e.width / e.height, 1 == h.pdfInfo.numPages ? (h.double = !1, h.model.trigger("pdfinit")) : h.getViewport(1, function(e) {
                h.r2 = e.width / e.height, h.double = 1.5 < h.r2 / h.r1, h.backCover = t || !0, h.model.trigger("pdfinit")
            })
        })
    }, this.loadOutline = function(t) {
        var n = this;
        this.pdfDocument.getOutline().then(function(e) {
            n.outline = e, n.outlineLoaded = !0, t.call(n, e)
        })
    }, this.startLoadingText = function() {
        this.loadingText = !0
    }, this.stopLoadingText = function() {
        this.loadingText = !1
    }, this.getViewport = function(e, t) {
        e >= h.pdfInfo.numPages || (h.pages[e] ? (h.viewports[e] = h.pages[e].getViewport({
            scale: 1
        }), t.call(h, h.viewports[e])) : i.getPage(e + 1).then(function(e) {
            h.pages[e.pageIndex] = e, h.getViewport(e.pageIndex, t)
        }))
    }, this.getAllViewports = function(e) {}, this.getText = function(n, i) {
        var a = this;
        this.getViewport(n, function(e) {
            var t = a.pages[n];
            a.getTextContent(t, function() {
                i.call(a, t)
            })
        })
    }, this.getTextAllPages = function(e) {
        var t = this;
        this.loadingTextFromPage = this.loadingTextFromPage || 0, this.getText(this.loadingTextFromPage, function() {
            t.loadingTextFromPage == t.numPages - 1 ? e && e.call(t) : (t.loadingTextFromPage++, t.getTextAllPages(e))
        })
    }, this.findInPage = function(e, t, n) {
        var i = this;
        this.findInPageCallbacks = this.findInPageCallbacks || [], this.findInPageCallbacks[t] = n, this.searchingString = e, this.pages[t] && this.pages[t].textContent ? i.findInPageTextContentAvailable(this.pages[t], t) : this.getText(t, function(e) {
            i.findInPageTextContentAvailable(e, t)
        })
    }, this.findInPageTextContentAvailable = function(e, t) {
        for (var n = e.textContent.items, i = 0, a = 0; a < n.length; a++) {
            var r = n[a].str;
            r.includes(this.searchingString) && i++, r.toUpperCase().includes(this.searchingString.toUpperCase()) && i++
        }
        var s = this.findInPageCallbacks[t];
        s && s.call(this, i, e.htmlContent), this.findInPageCallbacks[t] = null
    }, this.getThumb = function(s, o, l) {
        this.getViewport(s, function(e) {
            var t = h.pages[s];
            if (t.thumb) l.call(h, t.thumb);
            else {
                var n = o / h.viewports[s].height,
                    i = (e = t.getViewport({
                        scale: n
                    }), document.createElement("canvas")),
                    a = (t.thumb = i).getContext("2d");
                i.height = e.height, i.width = e.width;
                var r = {
                    canvasContext: a,
                    viewport: e
                };
                t.cleanupAfterRender = !0, t.render(r).then(function() {
                    t.cleanup(), l.call(h, t.thumb)
                })
            }
        })
    }, this.getPage = function(e, t) {
        var n = this;
        (n.double ? Math.round(e / 2) + 1 : e + 1) > this.pdfInfo.numPages || i.getPage(e).then(function(e) {
            n.renderPage(e, t)
        })
    }, this.renderPage = function(e, t, n) {
        var i = this;
        if (e.canvas = e.canvas || {}, e.canvas[t] && e.canvas[t].rendered) return n && n.call(i, e), void(n = null);
        e.rendering && setTimeout(function() {
            i.renderPage(e, t, n)
        }, 300), e.rendering = !0;
        var a = i.getCanvas();
        a.size = t, a.pdfPageIndex = e.pageIndex;
        var r = e.getViewport({
                scale: 1
            }),
            s = r.width <= r.height,
            o = s || !i.webgl ? t / r.height : t / r.width,
            l = e.getViewport({
                scale: o
            });
        a.width = l.width, a.height = l.height, i.webgl && (s ? (a.height = t, a.width = l.width > t ? l.width : t, a.scaleX = l.width / t, a.scaleY = 1) : (a.width = t, a.height = l.height > t ? l.height : t, a.scaleY = l.height / t, a.scaleX = 1));
        var h = a.getContext("2d");
        h.fillStyle = "#FFFFFF", h.fillStyle = "#000000";
        var d = {
            canvasContext: h,
            viewport: l
        };
        e.scale = o, e.canvas[t] = a, e.canvas[t].ratio = l.width / l.height, e.cleanupAfterRender = !0, e.render(d).promise.then(function() {
            d = null, n && n.call(i, e), e.rendering = !1, n = null
        })
    }, this.renderBookPage = function(e, t, n) {
        var i = this.options.doublePage ? Math.round(e / 2) : e;
        this.renderPageFromPdf(i, t, n)
    }, this.loadTextLayer = function(a, r) {
        var e = this.options.doublePage ? Math.round(a / 2) : a,
            s = this.pages[e],
            o = this;
        if (e >= this.pdfInfo.numPages && r.call(o), this.pages[e])
            if (s.htmlContent || (s.htmlContent = document.createElement("div"), s.htmlContent.classList.add("flipbook-page-htmlContent")), s.textContent) {
                var t = s.htmlContent,
                    n = s.pageIndex;
                if (!s.annotationLayer) new AnnotationLayerBuilder({
                    pageDiv: t,
                    pdfPage: s,
                    linkService: this.linkService
                }).render(s.getViewport({
                    scale: 1e3 / s.getViewport({
                        scale: 1
                    }).height
                }), "display"), s.annotationLayer = !0;
                if (u.doublePage)
                    if (0 == n) l(t, n);
                    else if (n == u.pages.length / 2) l(t, u.numPages - 1);
                else {
                    t.style.transformOrigin = "0 0";
                    var i = t.cloneNode(!0);
                    if (!s.annotationLayer2) new AnnotationLayerBuilder({
                        pageDiv: i,
                        pdfPage: s,
                        linkService: this.linkService
                    }).render(s.getViewport({
                        scale: 1e3 / s.getViewport({
                            scale: 1
                        }).height
                    }), "display"), s.annotationLayer2 = !0;
                    l(t, 2 * n - 1), l(i, 2 * n)
                } else l(t, n);
                r.call(this, s)
            } else s.getTextContent().then(function(e) {
                s.textContent = e;
                if (o.options.textLayer && !s.textLayer) {
                    s.textLayer = i;
                    var t = 1e3 / s.getViewport({
                            scale: 1
                        }).height,
                        n = document.createElement("div");
                    n.className = "flipbook-textLayer", s.htmlContent.appendChild(n), n.style.width = String(1e3 * s.getViewport({
                        scale: 1
                    }).width / s.getViewport({
                        scale: 1
                    }).height) + "px", n.style.height = "1000px";
                    var i = new TextLayerBuilder({
                        eventBus: o.eventBus,
                        textLayerDiv: n,
                        pageIndex: s.pageIndex,
                        viewport: s.getViewport({
                            scale: t
                        })
                    });
                    i.setTextContent(e), i.render(), o.eventBus.on("textlayerrendered", function(e) {
                        o.loadTextLayer(a, r)
                    })
                } else o.loadTextLayer(a, r)
            });
        else this.getViewport(e, function(e) {
            o.loadTextLayer(a, r)
        });

        function l(e, t) {
            var n = u.pages[t] || {};
            n.htmlContentInitialized || (n.htmlContent && jQuery(e).append(jQuery(n.htmlContent)), n.htmlContentInitialized = !0, n.htmlContent = e)
        }
    }, this.renderPageFromPdf = function(t, n, i) {
        var a = this;
        if (t >= this.pdfInfo.numPages && i.call(a), this.pages[t]) {
            var e = t,
                r = this.pages[t],
                s = r.getViewport({
                    scale: 1
                });
            Math.max(s.width, s.height), s.height;
            this.isRendering(e, n) ? setTimeout(function() {
                a.renderPageFromPdf(t, n, i)
            }, 300) : this.isRendered(e, n) ? this.onPdfPageRendered(a.pages[e], n, i) : this.renderPage(r, n, function(e) {
                a.onPdfPageRendered(e, n, i)
            })
        } else this.getViewport(t, function(e) {
            a.renderPageFromPdf(t, n, i)
        })
    }, this.onBookPageRendered = function(e, t, n, i) {
        n = n, i = i;
        this.model.trigger("pageLoaded", {
            index: n,
            size: i,
            canvas: t
        })
    }, this.getBookPage = function(t, n) {
        var i = null;
        return this.canvasBuffer.forEach(function(e) {
            e.pageIndex == t && e.size == n && (i = e)
        }), i
    }, this.onPdfPageRendered = function(e, t, n) {
        var i = this;
        if (e.canvas && e.canvas[t]) {
            var a = e.canvas[t],
                r = e.pageIndex;
            if (a.pdfPageIndex = r, u.doublePage)
                if (0 == r) a.pageIndex = 0, a.rendering = !1, a.rendered = !0, i.onBookPageRendered(e, a, 0, t);
                else if (r == u.pages.length / 2) a.pageIndex = u.numPages - 1, a.rendering = !1, a.rendered = !0, i.onBookPageRendered(e, a, u.numPages - 1, t);
            else if (i.webgl) a.double = !0, a.scaleX = a.width / 2 / t, a.scaleY = a.scaleY, a.pageIndex = 2 * r, a.rendering = !1, a.rendered = !0, i.onBookPageRendered(e, a, 2 * r, t), i.onBookPageRendered(e, a, 2 * r - 1, t);
            else {
                var s = i.options.rightToLeft ? 2 * r - 1 : 2 * r,
                    o = i.options.rightToLeft ? 2 * r : 2 * r - 1,
                    l = this.getBookPage(o, t);
                if (!l) {
                    (l = i.getCanvas()).size = t;
                    var h = l.getContext("2d");
                    l.width = a.width / 2, l.height = a.height, h.fillStyle = "#FFFFFF", l.pageIndex = o, l.pdfPageIndex = r, h.drawImage(a, 0, 0), l.rendering = !1, l.rendered = !0
                }
                i.onBookPageRendered(e, l, o, t);
                var d = this.getBookPage(s, t);
                if (!d) {
                    (d = i.getCanvas()).size = t;
                    var c = d.getContext("2d");
                    d.width = a.width / 2, d.height = a.height, c.fillStyle = "#FFFFFF", d.pageIndex = s, d.pdfPageIndex = r, c.drawImage(a, a.width / 2, 0, a.width / 2, a.height, 0, 0, a.width / 2, a.height), d.rendering = !1, d.rendered = !0
                }
                i.onBookPageRendered(e, d, s, t), a.size = 200, a.pageIndex = o, a.rendering = !1, a.rendered = !0
            } else a.pageIndex = r, a.size = t, a.rendering = !1, a.rendered = !0, i.onBookPageRendered(e, a, r, t);
            n && n.call(i, {
                canvas: a,
                lCanvas: l,
                rCanvas: d,
                size: t,
                pdfPageIndex: r,
                htmlContent: e.htmlContent
            }), n = null
        }
    }, this.getTextContent = function(t, n) {
        t.textContent ? n(t) : t.getTextContent().then(function(e) {
            t.textContent = e, n(t)
        })
    }, this.getCanvasByHeight = function(e, t, n) {}
}, FLIPBOOK.PdfService.prototype = {};
var _createClass = function() {
    function i(e, t) {
        for (var n = 0; n < t.length; n++) {
            var i = t[n];
            i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
        }
    }
    return function(e, t, n) {
        return t && i(e.prototype, t), n && i(e, n), e
    }
}();

function _classCallCheck(e, t) {
    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
}
var EventBus = function() {
        function n() {
            var e = (0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {}).dispatchToDOM,
                t = void 0 !== e && e;
            _classCallCheck(this, n), this._listeners = Object.create(null), this._dispatchToDOM = !0 === t
        }
        return _createClass(n, [{
            key: "on",
            value: function(e, t) {
                var n = this._listeners[e];
                n || (n = [], this._listeners[e] = n), n.push(t)
            }
        }, {
            key: "off",
            value: function(e, t) {
                var n = this._listeners[e],
                    i = void 0;
                !n || (i = n.indexOf(t)) < 0 || n.splice(i, 1)
            }
        }, {
            key: "dispatch",
            value: function(e) {
                var t = this._listeners[e];
                if (t && 0 !== t.length) {
                    var n = Array.prototype.slice.call(arguments, 1);
                    t.slice(0).forEach(function(e) {
                        e.apply(null, n)
                    }), this._dispatchToDOM && this._dispatchDOMEvent(e, n)
                } else if (this._dispatchToDOM) {
                    var i = Array.prototype.slice.call(arguments, 1);
                    this._dispatchDOMEvent(e, i)
                }
            }
        }, {
            key: "_dispatchDOMEvent",
            value: function(e, t) {
                var n = 1 < arguments.length && void 0 !== t ? t : null;
                if (this._dispatchToDOM) {
                    var i = Object.create(null);
                    if (n && 0 < n.length) {
                        var a = n[0];
                        for (var r in a) {
                            var s = a[r];
                            if ("source" !== r) i[r] = s;
                            else if (s === window || s === document) return
                        }
                    }
                    var o = document.createEvent("CustomEvent");
                    o.initCustomEvent(e, !0, !0, i), document.dispatchEvent(o)
                }
            }
        }]), n
    }(),
    EXPAND_DIVS_TIMEOUT = 300,
    MATCH_SCROLL_OFFSET_TOP = -50,
    MATCH_SCROLL_OFFSET_LEFT = -400,
    TextLayerBuilder = function() {
        function h(e) {
            var t = e.textLayerDiv,
                n = e.eventBus,
                i = e.pageIndex,
                a = e.viewport,
                r = e.findController,
                s = void 0 === r ? null : r,
                o = e.enhanceTextSelection,
                l = void 0 !== o && o;
            _classCallCheck(this, h), this.textLayerDiv = t, this.eventBus = n || (0, _dom_events.getGlobalEventBus)(), this.textContent = null, this.textContentItemsStr = [], this.textContentStream = null, this.renderingDone = !1, this.pageIdx = i, this.pageNumber = this.pageIdx + 1, this.matches = [], this.viewport = a, this.textDivs = [], this.findController = s, this.textLayerRenderTask = null, this.enhanceTextSelection = l, this._boundEvents = Object.create(null), this._bindEvents(), this._bindMouse()
        }
        return _createClass(h, [{
            key: "_finishRendering",
            value: function() {
                if (this.renderingDone = !0, !this.enhanceTextSelection) {
                    var e = document.createElement("div");
                    e.className = "endOfContent", this.textLayerDiv.appendChild(e)
                }
                this.eventBus.dispatch("textlayerrendered", {
                    source: this,
                    pageNumber: this.pageNumber,
                    numTextDivs: this.textDivs.length
                })
            }
        }, {
            key: "render",
            value: function(e) {
                var t = this,
                    n = 0 < arguments.length && void 0 !== e ? e : 0;
                if ((this.textContent || this.textContentStream) && !this.renderingDone) {
                    this.cancel(), this.textDivs = [];
                    var i = document.createDocumentFragment();
                    this.textLayerRenderTask = (0, pdfjsLib.renderTextLayer)({
                        textContent: this.textContent,
                        textContentStream: this.textContentStream,
                        container: i,
                        viewport: this.viewport,
                        textDivs: this.textDivs,
                        textContentItemsStr: this.textContentItemsStr,
                        timeout: n,
                        enhanceTextSelection: this.enhanceTextSelection
                    }), this.textLayerRenderTask.promise.then(function() {
                        t.textLayerDiv.appendChild(i), t._finishRendering(), t.updateMatches()
                    }, function(e) {})
                }
            }
        }, {
            key: "cancel",
            value: function() {
                this.textLayerRenderTask && (this.textLayerRenderTask.cancel(), this.textLayerRenderTask = null)
            }
        }, {
            key: "setTextContentStream",
            value: function(e) {
                this.cancel(), this.textContentStream = e
            }
        }, {
            key: "setTextContent",
            value: function(e) {
                this.cancel(), this.textContent = e
            }
        }, {
            key: "convertMatches",
            value: function(e, t) {
                var n = 0,
                    i = 0,
                    a = this.textContentItemsStr,
                    r = a.length - 1,
                    s = null === this.findController ? 0 : this.findController.state.query.length,
                    o = [];
                if (!e) return o;
                for (var l = 0, h = e.length; l < h; l++) {
                    for (var d = e[l]; n !== r && d >= i + a[n].length;) i += a[n].length, n++;
                    n === a.length && console.error("Could not find a matching mapping");
                    var c = {
                        begin: {
                            divIdx: n,
                            offset: d - i
                        }
                    };
                    for (d += t ? t[l] : s; n !== r && d > i + a[n].length;) i += a[n].length, n++;
                    c.end = {
                        divIdx: n,
                        offset: d - i
                    }, o.push(c)
                }
                return o
            }
        }, {
            key: "renderMatches",
            value: function(e) {
                if (0 !== e.length) {
                    var l = this.textContentItemsStr,
                        h = this.textDivs,
                        t = null,
                        n = this.pageIdx,
                        i = null !== this.findController && n === this.findController.selected.pageIdx,
                        a = null === this.findController ? -1 : this.findController.selected.matchIdx,
                        r = {
                            divIdx: -1,
                            offset: void 0
                        },
                        s = a,
                        o = s + 1;
                    if (null !== this.findController && this.findController.state.highlightAll) s = 0, o = e.length;
                    else if (!i) return;
                    for (var d = s; d < o; d++) {
                        var c = e[d],
                            u = c.begin,
                            g = c.end,
                            f = i && d === a ? " selected" : "";
                        if (this.findController && this.findController.selected.matchIdx === d && this.findController.selected.pageIdx === n) {
                            var v = {
                                top: MATCH_SCROLL_OFFSET_TOP,
                                left: MATCH_SCROLL_OFFSET_LEFT
                            };
                            (0, _ui_utils.scrollIntoView)(h[u.divIdx], v, !0)
                        }
                        if (t && u.divIdx === t.divIdx ? y(t.divIdx, t.offset, u.offset) : (null !== t && y(t.divIdx, t.offset, r.offset), m(u)), u.divIdx === g.divIdx) y(u.divIdx, u.offset, g.offset, "highlight" + f);
                        else {
                            y(u.divIdx, u.offset, r.offset, "highlight begin" + f);
                            for (var p = u.divIdx + 1, x = g.divIdx; p < x; p++) h[p].className = "highlight middle" + f;
                            m(g, "highlight end" + f)
                        }
                        t = g
                    }
                    t && y(t.divIdx, t.offset, r.offset)
                }

                function m(e, t) {
                    var n = e.divIdx;
                    h[n].textContent = "", y(n, 0, e.offset, t)
                }

                function y(e, t, n, i) {
                    var a = h[e],
                        r = l[e].substring(t, n),
                        s = document.createTextNode(r);
                    if (i) {
                        var o = document.createElement("span");
                        return o.className = i, o.appendChild(s), void a.appendChild(o)
                    }
                    a.appendChild(s)
                }
            }
        }, {
            key: "updateMatches",
            value: function() {
                if (this.renderingDone) {
                    for (var e = this.matches, t = this.textDivs, n = this.textContentItemsStr, i = -1, a = 0, r = e.length; a < r; a++) {
                        for (var s = e[a], o = Math.max(i, s.begin.divIdx), l = s.end.divIdx; o <= l; o++) {
                            var h = t[o];
                            h.textContent = n[o], h.className = ""
                        }
                        i = s.end.divIdx + 1
                    }
                    if (this.findController && this.findController.highlightMatches) {
                        var d = void 0,
                            c = void 0;
                        null !== this.findController && (d = this.findController.pageMatches[this.pageIdx] || null, c = this.findController.pageMatchesLength && this.findController.pageMatchesLength[this.pageIdx] || null), this.matches = this.convertMatches(d, c), this.renderMatches(this.matches)
                    }
                }
            }
        }, {
            key: "_bindEvents",
            value: function() {
                var n = this,
                    i = this.eventBus,
                    a = this._boundEvents;
                a.pageCancelled = function(e) {
                    if (e.pageNumber === n.pageNumber)
                        if (n.textLayerRenderTask) console.error("TextLayerBuilder._bindEvents: `this.cancel()` should have been called when the page was reset, or rendering cancelled.");
                        else
                            for (var t in a) i.off(t.toLowerCase(), a[t]), delete a[t]
                }, a.updateTextLayerMatches = function(e) {
                    e.pageIndex !== n.pageIdx && -1 !== e.pageIndex || n.updateMatches()
                }, i.on("pagecancelled", a.pageCancelled), i.on("updatetextlayermatches", a.updateTextLayerMatches)
            }
        }, {
            key: "_bindMouse",
            value: function() {
                var r = this,
                    s = this.textLayerDiv,
                    o = null;
                s.addEventListener("mousedown", function(e) {
                    if (r.enhanceTextSelection && r.textLayerRenderTask) return r.textLayerRenderTask.expandTextDivs(!0), void(o && (clearTimeout(o), o = null));
                    var t = s.querySelector(".endOfContent");
                    if (t) {
                        var n = e.target !== s;
                        if (n = n && "none" !== window.getComputedStyle(t).getPropertyValue("-moz-user-select")) {
                            var i = s.getBoundingClientRect(),
                                a = Math.max(0, (e.pageY - i.top) / i.height);
                            t.style.top = (100 * a).toFixed(2) + "%"
                        }
                        t.classList.add("active")
                    }
                }), s.addEventListener("mouseup", function() {
                    if (r.enhanceTextSelection && r.textLayerRenderTask) o = setTimeout(function() {
                        r.textLayerRenderTask && r.textLayerRenderTask.expandTextDivs(!1), o = null
                    }, EXPAND_DIVS_TIMEOUT);
                    else {
                        var e = s.querySelector(".endOfContent");
                        e && (e.style.top = "", e.classList.remove("active"))
                    }
                })
            }
        }]), h
    }(),
    DefaultTextLayerFactory = function() {
        function e() {
            _classCallCheck(this, e)
        }
        return _createClass(e, [{
            key: "createTextLayerBuilder",
            value: function(e, t, n, i) {
                return new TextLayerBuilder({
                    textLayerDiv: e,
                    pageIndex: t,
                    viewport: n,
                    enhanceTextSelection: 3 < arguments.length && void 0 !== i && i
                })
            }
        }]), e
    }(),
    PDFLinkService = function() {
        function s() {
            var e = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : {},
                t = e.eventBus,
                n = e.externalLinkTarget,
                i = void 0 === n ? null : n,
                a = e.externalLinkRel,
                r = void 0 === a ? null : a;
            _classCallCheck(this, s), this.eventBus = t || (0, _dom_events.getGlobalEventBus)(), this.externalLinkTarget = i, this.externalLinkRel = r, this.baseUrl = null, this.pdfDocument = null, this.pdfViewer = null, this.pdfHistory = null, this._pagesRefCache = null
        }
        return _createClass(s, [{
            key: "setDocument",
            value: function(e, t) {
                var n = 1 < arguments.length && void 0 !== t ? t : null;
                this.baseUrl = n, this.pdfDocument = e, this._pagesRefCache = Object.create(null)
            }
        }, {
            key: "setViewer",
            value: function(e) {
                this.pdfViewer = e
            }
        }, {
            key: "setHistory",
            value: function(e) {
                this.pdfHistory = e
            }
        }, {
            key: "navigateTo",
            value: function(s) {
                var o = this;
                new Promise(function(t, e) {
                    "string" != typeof s ? t({
                        namedDest: "",
                        explicitDest: s
                    }) : o.pdfDocument.getDestination(s).then(function(e) {
                        t({
                            namedDest: s,
                            explicitDest: e
                        })
                    })
                }).then(function(e) {
                    Array.isArray(e.explicitDest) ? function t(e) {
                        var n = e.namedDest,
                            i = e.explicitDest,
                            a = i[0],
                            r = void 0;
                        if (a instanceof Object) {
                            if (null === (r = o._cachedPageNumber(a))) return void o.pdfDocument.getPageIndex(a).then(function(e) {
                                o.cachePageRef(e + 1, a), t({
                                    namedDest: n,
                                    explicitDest: i
                                })
                            }).catch(function() {
                                console.error('PDFLinkService.navigateTo: "' + a + '" is not a valid page reference, for dest="' + s + '".')
                            })
                        } else {
                            if (!Number.isInteger(a)) return void console.error('PDFLinkService.navigateTo: "' + a + '" is not a valid destination reference, for dest="' + s + '".');
                            r = a + 1
                        }!r || r < 1 || r > o.pagesCount ? console.error('PDFLinkService.navigateTo: "' + r + '" is not a valid page number, for dest="' + s + '".') : (o.pdfHistory && (o.pdfHistory.pushCurrentPosition(), o.pdfHistory.push({
                            namedDest: n,
                            explicitDest: i,
                            pageNumber: r
                        })), o.pdfViewer.scrollPageIntoView({
                            pageNumber: r,
                            destArray: i
                        }))
                    }(e) : console.error('PDFLinkService.navigateTo: "' + e.explicitDest + '" is not a valid destination array, for dest="' + s + '".')
                })
            }
        }, {
            key: "getDestinationHash",
            value: function(e) {
                if ("string" == typeof e) return this.getAnchorUrl("#" + escape(e));
                if (Array.isArray(e)) {
                    var t = JSON.stringify(e);
                    return this.getAnchorUrl("#" + escape(t))
                }
                return this.getAnchorUrl("")
            }
        }, {
            key: "getAnchorUrl",
            value: function(e) {
                return (this.baseUrl || "") + e
            }
        }, {
            key: "setHash",
            value: function(e) {
                var t = void 0,
                    n = void 0;
                if (e.includes("=")) {
                    var i = (0, _ui_utils.parseQueryString)(e);
                    if ("search" in i && this.eventBus.dispatch("findfromurlhash", {
                            source: this,
                            query: i.search.replace(/"/g, ""),
                            phraseSearch: "true" === i.phrase
                        }), "nameddest" in i) return void this.navigateTo(i.nameddest);
                    if ("page" in i && (t = 0 | i.page || 1), "zoom" in i) {
                        var a = i.zoom.split(","),
                            r = a[0],
                            s = parseFloat(r);
                        r.includes("Fit") ? "Fit" === r || "FitB" === r ? n = [null, {
                            name: r
                        }] : "FitH" === r || "FitBH" === r || "FitV" === r || "FitBV" === r ? n = [null, {
                            name: r
                        }, 1 < a.length ? 0 | a[1] : null] : "FitR" === r ? 5 !== a.length ? console.error('PDFLinkService.setHash: Not enough parameters for "FitR".') : n = [null, {
                            name: r
                        }, 0 | a[1], 0 | a[2], 0 | a[3], 0 | a[4]] : console.error('PDFLinkService.setHash: "' + r + '" is not a valid zoom value.') : n = [null, {
                            name: "XYZ"
                        }, 1 < a.length ? 0 | a[1] : null, 2 < a.length ? 0 | a[2] : null, s ? s / 100 : r]
                    }
                    n ? this.pdfViewer.scrollPageIntoView({
                        pageNumber: t || this.page,
                        destArray: n,
                        allowNegativeOffset: !0
                    }) : t && (this.page = t), "pagemode" in i && this.eventBus.dispatch("pagemode", {
                        source: this,
                        mode: i.pagemode
                    })
                } else {
                    n = unescape(e);
                    try {
                        n = JSON.parse(n), Array.isArray(n) || (n = n.toString())
                    } catch (e) {}
                    if ("string" == typeof n || isValidExplicitDestination(n)) return void this.navigateTo(n);
                    console.error('PDFLinkService.setHash: "' + unescape(e) + '" is not a valid destination.')
                }
            }
        }, {
            key: "executeNamedAction",
            value: function(e) {
                switch (e) {
                    case "GoBack":
                        this.pdfHistory && this.pdfHistory.back();
                        break;
                    case "GoForward":
                        this.pdfHistory && this.pdfHistory.forward();
                        break;
                    case "NextPage":
                        this.page < this.pagesCount && this.page++;
                        break;
                    case "PrevPage":
                        1 < this.page && this.page--;
                        break;
                    case "LastPage":
                        this.page = this.pagesCount;
                        break;
                    case "FirstPage":
                        this.page = 1
                }
                this.eventBus.dispatch("namedaction", {
                    source: this,
                    action: e
                })
            }
        }, {
            key: "cachePageRef",
            value: function(e, t) {
                if (t) {
                    var n = t.num + " " + t.gen + " R";
                    this._pagesRefCache[n] = e
                }
            }
        }, {
            key: "_cachedPageNumber",
            value: function(e) {
                var t = e.num + " " + e.gen + " R";
                return this._pagesRefCache && this._pagesRefCache[t] || null
            }
        }, {
            key: "pagesCount",
            get: function() {
                return this.pdfDocument ? this.pdfDocument.numPages : 0
            }
        }, {
            key: "page",
            get: function() {
                return this.pdfViewer.currentPageNumber
            },
            set: function(e) {
                this.pdfViewer.currentPageNumber = e
            }
        }, {
            key: "rotation",
            get: function() {
                return this.pdfViewer.pagesRotation
            },
            set: function(e) {
                this.pdfViewer.pagesRotation = e
            }
        }]), s
    }();

function isValidExplicitDestination(e) {
    if (!Array.isArray(e)) return !1;
    var t = e.length,
        n = !0;
    if (t < 2) return !1;
    var i = e[0];
    if (!("object" === (void 0 === i ? "undefined" : _typeof(i)) && Number.isInteger(i.num) && Number.isInteger(i.gen) || Number.isInteger(i) && 0 <= i)) return !1;
    var a = e[1];
    if ("object" !== (void 0 === a ? "undefined" : _typeof(a)) || "string" != typeof a.name) return !1;
    switch (a.name) {
        case "XYZ":
            if (5 !== t) return !1;
            break;
        case "Fit":
        case "FitB":
            return 2 === t;
        case "FitH":
        case "FitBH":
        case "FitV":
        case "FitBV":
            if (3 !== t) return !1;
            break;
        case "FitR":
            if (6 !== t) return !1;
            n = !1;
            break;
        default:
            return !1
    }
    for (var r = 2; r < t; r++) {
        var s = e[r];
        if (!("number" == typeof s || n && null === s)) return !1
    }
    return !0
}
var SimpleLinkService = function() {
        function e() {
            _classCallCheck(this, e), this.externalLinkTarget = null, this.externalLinkRel = null
        }
        return _createClass(e, [{
            key: "navigateTo",
            value: function(e) {}
        }, {
            key: "getDestinationHash",
            value: function(e) {
                return "#"
            }
        }, {
            key: "getAnchorUrl",
            value: function(e) {
                return "#"
            }
        }, {
            key: "setHash",
            value: function(e) {}
        }, {
            key: "executeNamedAction",
            value: function(e) {}
        }, {
            key: "cachePageRef",
            value: function(e, t) {}
        }, {
            key: "pagesCount",
            get: function() {
                return 0
            }
        }, {
            key: "page",
            get: function() {
                return 0
            },
            set: function(e) {}
        }, {
            key: "rotation",
            get: function() {
                return 0
            },
            set: function(e) {}
        }]), e
    }(),
    AnnotationLayerBuilder = function() {
        function h(e) {
            var t = e.pageDiv,
                n = e.pdfPage,
                i = e.linkService,
                a = e.downloadManager,
                r = e.imageResourcesPath,
                s = void 0 === r ? "" : r,
                o = e.renderInteractiveForms,
                l = void 0 !== o && o;
            _classCallCheck(this, h), this.pageDiv = t, this.pdfPage = n, this.linkService = i, this.downloadManager = a, this.imageResourcesPath = s, this.renderInteractiveForms = l, this.div = null, this._cancelled = !1
        }
        return _createClass(h, [{
            key: "render",
            value: function(n, e) {
                var i = this,
                    t = 1 < arguments.length && void 0 !== e ? e : "display";
                this.pdfPage.getAnnotations({
                    intent: t
                }).then(function(e) {
                    if (!i._cancelled) {
                        var t = {
                            viewport: n.clone({
                                dontFlip: !0
                            }),
                            div: i.div,
                            annotations: e,
                            page: i.pdfPage,
                            imageResourcesPath: i.imageResourcesPath,
                            renderInteractiveForms: i.renderInteractiveForms,
                            linkService: i.linkService,
                            downloadManager: i.downloadManager
                        };
                        if (i.div) pdfjsLib.AnnotationLayer.update(t);
                        else {
                            if (0 === e.length) return;
                            i.div = document.createElement("div"), i.div.className = "annotationLayer", i.pageDiv.appendChild(i.div), t.div = i.div, pdfjsLib.AnnotationLayer.render(t)
                        }
                    }
                })
            }
        }, {
            key: "cancel",
            value: function() {
                this._cancelled = !0
            }
        }, {
            key: "hide",
            value: function() {
                this.div && this.div.setAttribute("hidden", "true")
            }
        }]), h
    }(),
    DefaultAnnotationLayerFactory = function() {
        function e() {
            _classCallCheck(this, e)
        }
        return _createClass(e, [{
            key: "createAnnotationLayerBuilder",
            value: function(e, t, n, i) {
                return new AnnotationLayerBuilder({
                    pageDiv: e,
                    pdfPage: t,
                    imageResourcesPath: 2 < arguments.length && void 0 !== n ? n : "",
                    renderInteractiveForms: 3 < arguments.length && void 0 !== i && i,
                    linkService: new SimpleLinkService
                })
            }
        }]), e
    }(),
    TEXT_LAYER_RENDER_DELAY = 200,
    MAX_TEXT_DIVS_TO_RENDER = 1e5,
    NonWhitespaceRegexp = /\S/;